# [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)

Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:

    Input: "babad"
    Output: "bab"
    Note: "aba" is also a valid answer.
Example 2:

    Input: "cbbd"
    Output: "bb"

-----

**题目**：给定一个字符串`s`，找出其中最长的回文子串。

**[思路](https://leetcode.com/problems/longest-palindromic-substring/discuss/2928/Very-simple-clean-java-solution)**：回文子串总共有两种形式，回文中心为奇数和偶数，因此分别对字符串中的每个字符/字符对为中心，判断外扩的字符是否相等。

[**工程代码下载**](https://github.com/abesft/leetcode)

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int res = 0;
        int maxlen = 0;
        for(int i = 0; i < s.size(); ++i){
            longestPalindrome(s, i, i, res, maxlen);
            longestPalindrome(s, i, i+1, res, maxlen);
        }
        return s.substr(res, maxlen);
    }
private:
    void longestPalindrome(string& s, int start, int end, int& res, int& maxlen) {
        while(start >=0 && end < s.size() && s[start] == s[end]){
            --start;
            ++end;
        }
        //注意这里的end-start-1其实是(end-1)-(start+1)+1
        if(end - start - 1 > maxlen){
            res = start + 1;
            maxlen = end - start - 1;
        };
    }
};
```

**[思路](https://blog.csdn.net/wangbaochu/article/details/53861833)**：回文字符串的子串也是回文，比如`P[i,j]`（表示以`i`开始以`j`结束的子串）是回文字符串，那么`P[i+1,j-1]`也是回文字符串。这样最长回文子串就能分解成一系列子问题了。这样需要额外的空间O（N\^2)，算法复杂度也是O(N\^2)。

状态方程和转移方程：

    P[i, j] = P[i+1, j-1], if ( s[i]==s[j] )
    P[i, j] = 0, if ( s[i] != s[j] )

其中`P[i,j]=0`表示子串`s[i..j]`不是回文串；`P[i,j]=1`表示子串`s[i..j]`是回文串。

```python
class Solution:
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        length = len(s)
        flag = [[False] * length for i in range(length)]
        # flag[i][j]表示s[i]至s[j]区间内（包含端点）的字符为回文
        start = 0
        longest = 1

        for i in range(length):
            flag[i][i] = True
            # 回文可能是abba这种情况
            if i < length - 1 and s[i] == s[i + 1]:
                flag[i][i + 1] = True
                start = i
                longest = 2

        # 循环回文可能的长度
        for test_len in range(3, length + 1):
            # 子串的起始点
            for i in range(length - test_len + 1):
                j = i + test_len - 1  # 子串的终点，减1是因为子串长度为 终点序号-起点序号+1
                if flag[i + 1][j - 1] and s[i] == s[j]:
                    start = i
                    longest = test_len
                    flag[i][j] = True

        return s[start:start + longest]
```
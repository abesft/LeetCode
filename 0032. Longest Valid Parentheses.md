# [32. Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)

Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.

**Example 1:**

```
Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
```

**Example 2:**

```
Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
```

-----

**题目**：最长的有效括号对。

**思路**：动态规划。参考[Approach 2: Using Dynamic Programming](https://leetcode.com/problems/longest-valid-parentheses/solution/)。对于前`i`个元素组成的子串，我们把包含`s[i]`在内的的最长有效括号对的长度记为`dp[i]`，那么如果`s[i]==（`，显然`dp[i]=0`；如果`s[i]==)`，那么`dp[i]`可以根据`s[i-1]`来更新状态：

- `s[i-1]=(`，此时`dp[i-1]=0`，`dp[i]=dp[i-2]+2`
- `s[i-1]=)`，此时`s[i]`应匹配到上一个未匹配的`(`，因为`s[i-1]`匹配长度为`dp[i-1]`，因此`s[i]`匹配至`s[j] = s[i-1-dp[i-1]]`，如果`s[j]=(`，那么`dp[i] = dp[i-1]+2+dp[j-1]`。



![在这里插入图片描述](https://img-blog.csdnimg.cn/20190522191245792.gif)



[**工程代码下载**](https://github.com/shenkh/leetcode)

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        if(n == 0) return 0;
        vector<int> dp(n);
        int res = 0;
        for(int i = 1; i < n; ++i){
            if(s[i] == ')'){
                if(s[i-1] == '('){
                    dp[i] = (i-2) >=0 ? dp[i-2] + 2 : 2;
                }
                else if(s[i-1] == ')'){
                    int j = i - 1 - dp[i-1];
                    if(j >=0 && s[j] == '(')
                    	dp[i] = (j-1) >= 0 ? dp[i-1] + 2 + dp[j-1] : dp[i-1] + 2;
                }
                res = max(res, dp[i]);
            }
        }
        return res;
    }
};
```


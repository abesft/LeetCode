# [680. Valid Palindrome II](https://leetcode.com/problems/valid-palindrome-ii/)

Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.

Example 1:

    Input: "aba"
    Output: True

Example 2:

    Input: "abca"
    Output: True
    Explanation: You could delete the character 'c'.

Note:

    The string will only contain lowercase characters a-z. The maximum length of the string is 50000.

-----

**题目**：给定一个字符串`s`，判断该字符串是否满足回文，其中可以删除`s`中的某个字符再判断其是否为回文字符串。

**思路**：暴力循环,[AC. Runtime: 4148 ms, faster than 1.82%]。创建一个与`s`反向的字符串`s_reverse`，首先判断两者是否相等，如果不相等，则每次删除一个字符(`s[i]`从前往后，`s_reverse`从后往前)，判断删除后的字符是否相等，如果相等，则说明找到了一个回文字符串，返回`true`。

[**工程代码下载**]()

```cpp
class Solution {
public:
    bool validPalindrome(string s) {
        string s_reverse;
        for(auto iter=s.rbegin(); iter!=s.rend(); ++iter)
            s_reverse.push_back(*iter);

        if(s == s_reverse) return true;
        for(int i=0; i<s.size(); ++i){
            string tmp1 = s;
            string tmp2 = s_reverse;

            if(tmp1.erase(i, 1) == tmp2.erase(s.size()-i-1, 1)){
                //cout << tmp1 << "," << tmp2 << endl;
                return true;
            }
        }
        return false;
    }
};
```

**思路2**：贪婪算法，参见[Approach #2: Greedy [Accepted]](https://leetcode.com/problems/valid-palindrome-ii/solution/)。首先确定`s[i]`是否等于`s[j], j=s.size()-i-1`，如果相等，`++i, --j`继续判断，直到`i>j`则停止循环。如果不相等，则判断删除了`s[i]`或者`s[j]`后，`s[i....j]`之间的字符串是否为回文，如果这两种情况`s[i....j]`都不是回文，则返回`false`。

```cpp
class Solution {
public:
    bool is_palindrome(string &s, int i, int j){
        for(int k = i; k <= i+(j-i)/2; ++k)
            if(s[k] != s[j-k+i])
                return false;
        return true;
    }

    bool validPalindrome(string s) {
        for(int i=0; i<s.size()/2; ++i){
            if(s[i] != s[s.size()-1-i])
                return is_palindrome(s, i+1, s.size()-1-i) || is_palindrome(s, i, s.size()-1-i-1);
        }
        return true;
    }
};
```
# []()

-----

**题目**：一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。

**思路**：https://blog.csdn.net/xieliang0717/article/details/73438037

[**工程代码下载**](https://github.com/abesft/leetcode)

```cpp
class Solution {
public:
    void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) {
        int res = 0;
        for(auto item : data)
            res ^= item;
        if(res == 0) return;

        //从后往前找到xor第一个非0的位
        int index = 0;
        while((res & 1) == 0){
            res = res >> 1;
            ++index;
        }

        //根据第n位是不是1将数据分为两部分
        *num1 = 0, *num2 = 0;
        for(auto item : data){
            if(nPosIsNonZero(item, index))
                *num1 ^= item;
            else
                *num2 ^= item;
        }
    }
private:
    //判断输入的num的第n位是不是二进制1
    bool nPosIsNonZero(int num, int n){
        num = num >> n;
        return (num & 1);
    }
};
```

-----

http://blademastercoder.github.io/2015/01/27/leetcode-findnum.html

- 如果一个数组中，每个数字都出现偶数次，只有一个数字出现一次，利用异或即可

- 如果一个数组中，每个数字都出现奇数(大于1)次，只有一个数字出现一次，那么就用一个32位的数组，记录所有位中为1的个数，最后数组中每一个数字对这个奇数取余，不为0的，把它取出，按它的位数，转化成十进制的数字。

```cpp
public static   int singleNumber(int[] A) {
    int bits[] = new int[32]; //定义一个32位数组       
    for (int i = 0; i < bits.length; i++) {
    	bits[i]=0;			//初始化  数组中所有值为0
	}            
    for (int i = 0; i < A.length; i++) {    	//对数组中每一个数字    	        	
		for (int j = 0; j < bits.length; j++) {	//这个数字的每一位			
			bits[j] += ((A[i] >> j) & 1);		//记录这个位上是否为1，为1的话 bits数组就加1		
		}
	}              
    int result = 0 ;               
    for (int j = 0; j < 32; j++)  				
        if (bits[j] % 3 != 0)  		//对3取余，是3的倍数的取余后都为0，剩下的就是我们要的
          result += (1 << j);       //把记录的二进制他转化成整形数字       
    return result;
}
```
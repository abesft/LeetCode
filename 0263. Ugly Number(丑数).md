# Ugly Number

## [263. Ugly Number](https://leetcode.com/problems/ugly-number/)

Write a program to check whether a given number is an ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.

Example 1:

    Input: 6
    Output: true
    Explanation: 6 = 2 × 3

Example 2:

    Input: 8
    Output: true
    Explanation: 8 = 2 × 2 × 2

Example 3:

    Input: 14
    Output: false
    Explanation: 14 is not ugly since it includes another prime factor 7.

Note:

- 1 is typically treated as an ugly number.
- Input is within the 32-bit signed integer range: [−2^31,  2^31 − 1].

-----

**题目**：判断输入的数是否为丑数。

**思路**：分别对2,3,5进行取余判断，如果取余为0，则将`num`除以对应的数，判断最后剩下的值是否为`1`。

[**工程代码下载**](https://github.com/abesft/leetcode)

```cpp
class Solution {
public:
    bool isUgly(int num) {
        if(num <= 0) return false;
        for(int i = 2; i <=5; ++i){
            while(num % i == 0){
                num /= i;
            }
        }
        return num == 1;
    }
};
```

## 264. [Ugly Number II](https://leetcode.com/problems/ugly-number-ii/)

Write a program to find the n-th ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.

Example:

    Input: n = 10
    Output: 12
    Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.

Note:

- 1 is typically treated as an ugly number.
- n does not exceed 1690.

-----

**题目**：第n个丑数。

**思路**：参见[C++ DP solution with short explanation](https://leetcode.com/problems/ugly-number-ii/discuss/69364/My-16ms-C%2B%2B-DP-solution-with-short-explanation).

We have an array k of first n ugly number. We only know, at the beginning, the first one, which is 1. Then

k[1] = min( k[0]x2, k[0]x3, k[0]x5). The answer is k[0]x2. So we move 2's pointer to 1. Then we test:

k[2] = min( k[1]x2, k[0]x3, k[0]x5). And so on. Be careful about the cases such as 6, in which we need to forward both pointers of 2 and 3.

x here is multiplication.

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        if(n <= 0) return 0;
        if(n == 1) return 1;
        vector<int> k(n);
        k[0] = 1;
        int t2 = 0, t3 = 0, t5 = 0;
        for(int i = 1; i < n; ++i){
            k[i] = min(2*k[t2], min(3*k[t3], 5*k[t5]));
            if(2*k[t2] == k[i]) ++t2;
            if(3*k[t3] == k[i]) ++t3;
            if(5*k[t5] == k[i]) ++t5;
        }
        return k[n-1];
    }
};
```
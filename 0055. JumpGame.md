# [55. Jump Game](https://leetcode.com/problems/jump-game/)

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

Example 1:

    Input: [2,3,1,1,4]
    Output: true
    Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.

Example 2:

    Input: [3,2,1,0,4]
    Output: false
    Explanation: You will always arrive at index 3 no matter what. Its maximum
                jump length is 0, which makes it impossible to reach the last index.

---------------

**题目**: 给定一个数组`nums`，数组中每个元素代表最多能前进的步数。数组中的值均为非负。初始位置在第一个元素，判断是否能走到最后一个位置。

**思路**: 利用回溯的思想。对当前位置下的所有可能前进的步数进行单独递归判断，用`current_pos`表示当前所在的位置，如果递归到某一个位置，比如能前进的步数为`0`，同时还未到达最后一个位置，则回溯到上一个状态。具体见代码注释。

**[思路](https://leetcode.com/problems/jump-game/discuss/20917/Linear-and-simple-solution-in-C%2B%2B)**: 对数组`nums`，每次更新前`i`个数所能达到的最远的位置`max_next_position`。如果`i+1`小于`max_next_position`，说明前`i`个值中肯定存在一条路径使得其从起点达到位置`i+1`，继续循环。如果能走到终点，此时`i`等于`nums.size()`。**【推荐】**

```cpp
#include<iostream>
#include<vector>
using namespace std;

//*Time Limit Exceeded*
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.size() == 0 || nums.size() == 1)
            return true;
        return backtraking(nums, 0);
    }

private:
    bool backtraking(vector<int>& nums, int current_pos){
        //只要到达或超过最后一个位置就返回
        if(current_pos >= nums.size()-1)
            return true;

        //循环当前位置下所有可能前进的步数
        for(int i = 1; i <= nums[current_pos]; ++i){
            // cout << current_pos + i << endl;
            //注意这里的写法，不能直接return backtraking(nums, current_pos + i)。
            //因为backtracking返回为false时，for循环可能还没结束
            if(backtraking(nums, current_pos + i))
                return true;
        }

        return false;
    }
};

//https://leetcode.com/problems/jump-game/discuss/20917/Linear-and-simple-solution-in-C%2B%2B
class Solution2 {
public:
    bool canJump(vector<int>& nums) {
        if(nums.size() == 0 || nums.size() == 1)
            return true;

        int max_next_position = 0;
        int i = 0;
        //每次更新前i个数能达到的最远的位置，判断i是否能走到最后一个位置
        for(; i < nums.size() && i <= max_next_position; ++i){
            max_next_position = max(max_next_position, i+nums[i]);
        }
        return i == nums.size();
    }
};

int main(int argc, char const *argv[])
{
    Solution sln;
    vector<int> testcase{3,2,1,0};
    cout << sln.canJump(testcase) << endl;
    return 0;
}
```

**思路**: 利用贪心的思想。记当前所在位置为`pos`，在能够前进的区域`[pos+1, pos+nums[pos]]`内，找到一个使得下次能跳的最远的`new_pos`，该值由以下计算得出：`max(i + nums[i]), for i in [pos+1, pos+nums[pos]]`。

```cpp
bool canJump(vector<int>& nums) {
    int i = 0;
    if (nums.size() < 1)
        return false;

    while (i < nums.size() - 1)
    {
        if (nums[i] == 0)
            break;

        vector<int> greed;
        for (size_t j = 1; j <= nums[i]; j++)
        {
            if (i + j >= nums.size())
                return true;
            else
                greed.push_back(nums[i + j] + j);
        }

        auto iter = max_element(greed.begin(), greed.end());
        i = i + 1 + distance(greed.begin(), iter);
        cout << nums[i] << endl;
    }
    if (i >= nums.size() - 1)
        return true;
    else
        return false;
}

```